<operation>
	<services>

		<service name="OracleDB"
				 adminPort="1521"
				 connectionPattern="jdbc:oracle:thin:@${target.address}:${target.port}:${target.prop.sid}">

			<properties>
				<property name="sid" required="true"/>
				<property name="pumpDbDir" required="true"/>
				<property name="driver" value="oracle.jdbc.driver.OracleDriver"/>
			</properties>

			<validations>
				<validation name="OraId" regex="^[a-zA-Z]+?[\w_]*$"/>
				<validation name="OraIdList" regex="^[a-zA-Z]+?[\w_]*?(,[ ]*?[a-zA-Z]+?[\w_]*?)*?$"/>
				<validation name="OraPass" regex="[^@'&quot;]+"/>
			</validations>

			<commands>

				<command name="listUser" listView="true">
					<params>
						<param name="Username" validRef="OraId"/>
						<param name="AccountStatus" stringLiterals="OPEN|LOCKED|EXPIRED &amp; LOCKED"/>
					</params>

					<body><![CDATA[
def map = $input('Username', 'AccountStatus > account_status')

db {
	prompt "Show ${map.isEmpty() ? 'All' : 'Filtered'} Users"
	query """
		select
			us.user_id,
			us.username,
			us.account_status,
			us.lock_date,
			us.default_tablespace,
			us.created,
			tbl.table_count
		from
			dba_users us
			left join (
				select
					owner,
					count(1) table_count
				from dba_tables
				group by owner) tbl on tbl.owner = us.username
		where
			1=1
			%FILTER%
		order by us.username"""
	filters map
}

]]></body>
				</command>

				<command name="createUser">
					<params>
						<param name="Username" required="true" validRef="OraId"/>
						<param name="Password" validRef="OraPass"/>
						<param name="ResourceRole" type="Boolean" required="true" defaultValue="true"/>
						<param name="UnlimitedTBS" type="Boolean" required="true" defaultValue="false"/>
						<param name="DBARole" type="Boolean" required="true" defaultValue="false"/>
					</params>

					<body><![CDATA[
if(checkUser([Username: Username]))
	$error('User already exists')

def pass = Username
if($param('Password'))
	pass = Password

db {
	prompt "Create User: '${Username}'"
	query """ create user "${Username}" identified by "${pass}" """
}

db {
	prompt "Grant Connect: '${Username}'"
	query "grant connect to ${Username}"
}

grantUser([Username: Username, ResourceRole: ResourceRole, UnlimitedTBS: UnlimitedTBS, DBARole: DBARole])
]]></body>
				</command>

				<command name="grantUser">
					<params>
						<param name="Username" required="true" validRef="OraId"/>
						<param name="ResourceRole" type="Boolean" required="true" defaultValue="true"/>
						<param name="UnlimitedTBS" type="Boolean" required="true" defaultValue="false"/>
						<param name="DBARole" type="Boolean" required="true" defaultValue="false"/>
					</params>

					<body><![CDATA[
if(ResourceRole)
	db {
		prompt "Grant Resource Role: '${Username}'"
		query "grant resource to ${Username}"
	}

if(UnlimitedTBS)
	db {
		prompt "Grant Unlimited Tablespace: '${Username}'"
		query "grant unlimited tablespace to ${Username}"
	}

if(DBARole)
	db {
		prompt "Grant DBA Role: '${Username}'"
		query "grant dba to ${Username}"
	}
]]></body>
				</command>

				<command name="changePassword">
					<params>
						<param name="Username" required="true" validRef="OraId"/>
						<param name="NewPassword" required="true" validRef="OraPass"/>
					</params>

					<body><![CDATA[
db {
	prompt "Change Password for '${Username}'"
	query """ alter user ${Username} identified by "${NewPassword}" account unlock """
}
$userPasswordUpdated(Username, NewPassword)
]]></body>
				</command>

				<command name="checkUser">
					<params>
						<param name="Username" required="true" validRef="OraId"/>
					</params>

					<body>
						<![CDATA[
db {
	prompt "Check User '${Username}'"
	query "select count(1) from all_users where username = upper('${Username}')"
	result {
		it > 0
	}
}
]]></body>
				</command>

				<command name="findOsDir">
					<params/>

					<body><![CDATA[
db {
	prompt 'Find OS-Directory of DB-Directory'
	query "select directory_path from all_directories where directory_name='${target.prop.pumpDbDir}'"
}
]]></body>
				</command>

				<command name="listDump">
					<params>
						<param name="Name"/>
					</params>

					<body><![CDATA[
def osDir = findOsDir()

def fileName = '*'
if($param('Name'))
	fileName = "*${Name}*"

ssh {
	prompt 'List Dump Files'
	cmd """ find ${osDir} -maxdepth 1 -iname "${fileName}.dmp" -printf "%TY-%Tm-%Td %TH:%TM|%f\n" | sort -r """
	result {
		it.toTabular("[|]")
		  .prepend("Time|DumpFile\n")
	}
}
]]></body>
				</command>

				<command name="backupSchema">
					<params>
						<param name="Schemas" required="true" validRef="OraIdList"/>
						<param name="Content" stringLiterals="ALL|DATA_ONLY|METADATA_ONLY" defaultValue="ALL"
							   required="true"/>
						<param name="Force" type="Boolean" required="true" defaultValue="false"/>
					</params>

					<body><![CDATA[
def availSchema = ''
Schemas.split(',').each {
	def username = it.trim()

	if(checkUser([Username: username])) {
		availSchema += ",${username}"
	} else if(!Force) {
			$error("Schema '${username}' does not exist!")
	}
}

if(availSchema.length() > 1) {
	availSchema = availSchema.substring(1)
	def file = "exp.${availSchema.replace(',', '.')}.${$now()}"
	ssh {
		prompt "Create Export from '${availSchema}' as '${file}.dmp'"
		cmd "su - oracle -c 'expdp ${target.username}/${target.password} schemas=${availSchema} directory=${target.prop.pumpDbDir} dumpfile=${file}.dmp logfile=${file}.log content=${Content}'"
	}
	return file
}
]]></body>
				</command>

				<command name="restoreSchema">
					<params>
						<param name="DumpFile" required="true"/>
						<param name="SourceSchemas" required="true" validRef="OraIdList"/>
						<param name="DestSchemas" validRef="OraIdList"/>
						<param name="Content" stringLiterals="ALL|DATA_ONLY|METADATA_ONLY" defaultValue="ALL"
							   required="true"/>
						<param name="DoBackUp" type="Boolean" required="true" defaultValue="false"/>
						<param name="IgnoreTrigger" type="Boolean" required="true" defaultValue="true"/>
					</params>

					<body><![CDATA[
def users = $param('DestSchemas') ? DestSchemas : SourceSchemas

if(Content != 'DATA_ONLY')
	dropUser([Usernames: users, DoBackup: DoBackUp, DoKillSession: true])

if(DumpFile.endsWith('.dmp'))
	DumpFile = DumpFile.substring(0, DumpFile.length() - 4)

def genParams = "directory=${target.prop.pumpDbDir} dumpfile=${DumpFile}.dmp logfile=imp.${DumpFile}.log transform=OID:n content=${Content}"
if(IgnoreTrigger)
	genParams += " exclude=trigger"

if($param('DestSchemas')) {
	def remap = generateRemap([SourceSchemas: SourceSchemas, DestSchemas: DestSchemas])
	ssh {
		prompt "Restoring '${remap}' from '${DumpFile}'"
		cmd "su - oracle -c 'impdp ${target.username}/${target.password} remap_schema=${remap} ${genParams}'"
		force true
	}

	DestSchemas.split(',').each {
		def username = it.trim()
		changePassword([Username: username, NewPassword: username.toLowerCase()])
	}
} else {
	ssh {
		prompt "Restoring '${SourceSchemas}' from '${DumpFile}'"
		cmd "su - oracle -c 'impdp ${target.username}/${target.password} ${genParams}'"
		force true
	}
}
]]></body>
				</command>

				<command name="generateRemap">
					<params>
						<param name="SourceSchemas" required="true"/>
						<param name="DestSchemas" required="true"/>
					</params>

					<body><![CDATA[
def srcArr = SourceSchemas.split(',')
def dstArr = DestSchemas.split(',')

if(srcArr.length != dstArr.length)
	$error('Unequal number of schemas in source and destination')
else {
	def remap = "${srcArr[0].trim()}:${dstArr[0].trim()}"
	for(def i=1; i < srcArr.length; i++) {
		def srcSchema = srcArr[i].trim()
		def dstSchema = dstArr[i].trim()
		if(srcSchema.length() > 0 && dstSchema.length() > 0) {
			remap += ",${srcSchema}:${dstSchema}"
		}
	}
	return remap
}
]]></body>
				</command>

				<command name="killUserSession">
					<params>
						<param name="Usernames" required="true" validRef="OraIdList"/>
					</params>

					<body><![CDATA[
Usernames.split(',').each {
	def username = it.trim()

	db {
		prompt "Kill All Sessions for User: '${username}'"
		query """
			declare
				v_schema varchar2(128);
			begin
				v_schema := '${username.toUpperCase()}';
				if v_schema in ('SYS','DBSNMP','SYSMAN', 'SYSTEM') then
					raise_application_error(-20001, 'Session belongs to illegal user. You can not kill ${username}!');
				end if;

				for i in (select sid, serial# from v\$session where username = v_schema)
				loop
					execute immediate 'alter system kill session '''|| i.sid || ',' || i.serial# || ''' immediate';
				end loop;
			end; """
	}
}
]]></body>
				</command>

				<command name="dropUser">
					<params>
						<param name="Usernames" required="true" validRef="OraIdList"/>
						<param name="DoBackup" type="Boolean" defaultValue="true" required="true"/>
						<param name="DoKillSession" type="Boolean" defaultValue="false" required="true"/>
					</params>

					<body><![CDATA[
if(DoBackup)
	backupSchema([Schemas: Usernames, Force: true])

Usernames.split(',').each {
	def username = it.trim()

	if(checkUser([Username: username])) {
		if(DoKillSession)
			killUserSession([Usernames: username])

		$sleep(10000)

		db {
			prompt "Drop User '${username}'"
			query "drop user ${username} cascade"
		}
	}
}
]]></body>
				</command>

				<command name="copySchema">
					<params>
						<param name="SourceSchemas" required="true" validRef="OraIdList"/>
						<param name="DestSchemas" validRef="OraIdList"/>
						<param name="DestServer" type="Service"/>
						<param name="Content" stringLiterals="ALL|DATA_ONLY|METADATA_ONLY" defaultValue="ALL"
							   required="true"/>
						<param name="DoBackUpDest" type="Boolean" required="true" defaultValue="true"/>
						<param name="IgnoreTrigger" type="Boolean" required="true" defaultValue="true"/>
					</params>

					<body><![CDATA[
if($param('DestServer'))
	copyRemoteSchema([SourceSchemas: SourceSchemas, DestSchemas: $param('DestSchemas'), DestServer: DestServer, DoBackUpDest: DoBackUpDest, IgnoreTrigger: IgnoreTrigger, Content: Content])

else {
	if(!$param('DestSchemas'))
		$error('Dest schemas are required in copy local')

	copyLocalSchema([SourceSchemas: SourceSchemas, DestSchemas: $param('DestSchemas'), DoBackUpDest: DoBackUpDest, IgnoreTrigger: IgnoreTrigger, Content: Content])
}
]]></body>
				</command>

				<command name="copyLocalSchema">
					<params>
						<param name="SourceSchemas" required="true" validRef="OraIdList"/>
						<param name="DestSchemas" required="true" validRef="OraIdList"/>
						<param name="Content" stringLiterals="ALL|DATA_ONLY|METADATA_ONLY" defaultValue="ALL"
							   required="true"/>
						<param name="DoBackUpDest" type="Boolean" defaultValue="true"/>
						<param name="IgnoreTrigger" type="Boolean" defaultValue="true"/>
					</params>

					<body><![CDATA[
if(SourceSchemas == DestSchemas)
	$error('Source and destination schemas must be different')

def file = backupSchema([Schemas: SourceSchemas, Content: Content])
restoreSchema([DumpFile: file, SourceSchemas: SourceSchemas, DestSchemas: DestSchemas, DoBackUp: DoBackUpDest, IgnoreTrigger: IgnoreTrigger, Content: Content])

def osDir = findOsDir()
ssh {
	prompt "Delete source dump file: ${file}"
	cmd "rm -f ${osDir}/${file}.dmp"
}
]]></body>
				</command>

				<command name="copyRemoteSchema">
					<params>
						<param name="SourceSchemas" required="true" validRef="OraIdList"/>
						<param name="DestSchemas" validRef="OraIdList"/>
						<param name="DestServer" type="Service" required="true"/>
						<param name="Content" stringLiterals="ALL|DATA_ONLY|METADATA_ONLY" defaultValue="ALL"
							   required="true"/>
						<param name="DoBackUpDest" type="Boolean" required="true" defaultValue="true"/>
						<param name="IgnoreTrigger" type="Boolean" required="true" defaultValue="true"/>
					</params>

					<body><![CDATA[
SourceSchemas.split(',').each {
	def username = it.trim()

	if(!checkUser([Username: username])) {
		$error("Schema '${username}' does not exist!")
	}
}

def srcServer = target
def dbLinkName = "dbl${srcServer.id}_${DestServer.id}_${$now()}"

def dest = SourceSchemas
if($param('DestSchemas'))
	dest = DestSchemas

$reTarget(DestServer, {

	db {
		prompt "Create Database Link on Dest: ${dbLinkName}"
		query """
			create database link ${dbLinkName}
			connect to ${srcServer.username} identified by "${srcServer.password}"
			using '
			(DESCRIPTION=
				(ADDRESS=
					(PROTOCOL=TCP)
					(HOST=${srcServer.address})
					(PORT=${srcServer.port})
				)
				(CONNECT_DATA=
					(SID=${srcServer.prop.sid})
				)
			)' """
	}

	dropUser([Usernames: dest, DoBackup: DoBackUpDest, DoKillSession: true])

	def file = "net.${dest.replace(',', '.')}.${$now()}"
	def genParams = "schemas=${SourceSchemas} directory=${target.prop.pumpDbDir} network_link=${dbLinkName} logfile=${file}.log transform=OID:n content=${Content}"
	if(IgnoreTrigger)
		genParams += " exclude=trigger"

	if(SourceSchemas == dest) {
		ssh {
			prompt "Import Database from: '${srcServer}', file='${file}', schemas='${SourceSchemas}'"
			cmd "su - oracle -c 'impdp ${target.username}/${target.password} ${genParams}'"
			force true
		}

	} else {
		def remap = generateRemap([SourceSchemas: SourceSchemas, DestSchemas: dest])
		ssh {
			prompt "Import Database from: '${srcServer}', file='${file}', remap=${remap}"
			cmd "su - oracle -c 'impdp ${target.username}/${target.password} remap_schema=${remap} ${genParams}'"
			force true
		}
	}

	db {
		prompt "Drop Database Link on Dest: '${target}' - Name=${dbLinkName}"
		query "drop database link ${dbLinkName}"
	}
})
]]></body>
				</command>

				<command name="listSession">
					<params>
						<param name="Username"/>
						<param name="OSUser"/>
						<param name="Machine"/>
						<param name="Program"/>
					</params>

					<body><![CDATA[
def map = $input('Username', 'OSUser', 'Machine', 'Program')

db {
	prompt "List ${map.isEmpty() ? 'All' : 'Filtered'} Sessions"
	query "select sid, serial# as serial, username, status, schemaname, osuser, machine, program from v\$session where 1=1 %FILTER%"
	filters map
}
]]></body>
				</command>

				<!--
								<command name="truncateSchema">
									<params>
										<param name="Schema" required="true"/>
									</params>

									<body><![CDATA[
				db {
					prompt "Truncate Tables/Sequences/Synonyms for '${Schema}'"
					query """
						declare
							v_schema varchar2(20);
						begin
							v_schema := '${Schema.toUpperCase()}';

							- -Bye Sequences!
							for i in (select us.sequence_name from all_sequences us where us.sequence_owner = v_schema) loop
								execute immediate 'drop sequence '||v_schema||'.'|| i.sequence_name;
							end loop;

							- -Bye Synonyms!
							for i in (select us.synonym_name from all_synonyms us where us.owner = v_schema) loop
								execute immediate 'drop synonym '||v_schema||'.'|| i.synonym_name;
							end loop;

							- -Bye Tables!
							for i in (select ut.table_name from all_tables ut where ut.owner = v_schema) loop
								execute immediate 'drop table '||v_schema||'.'|| i.table_name ||' cascade constraints purge';
							end loop;
						end;"""
				}
				]]></body>
								</command>
				-->
			</commands>

		</service>

	</services>
</operation>
